**Notes:**

1. The problem asks us to find the minimum number of intervals we can remove from a given list of intervals to make it non-overlapping.
2. The first most important thing is that the order of the interval list is important. If we keep the order random then it will take more time to remove the intervals. So the best of course of action is to sort the list based on the starting value. This will keep the list in order on the number line and then we can easily decide which intervals we need to remove.
3. After sorting the given list, we need to iterate over the list and increment the result by one if we found an overlapping interval. How do we find the overlapping interval. Well we compare the end of the previous interval with the start of the interval i. Basically we will compare adjacent intervals. So we will start our loop from the second interval in the list to the end. We will save the end of previous interval in a variable. So we can compare the end of previous and start of the next interval inside the loop.
4. If the previous end is greater than the start of the next interval. It means we have an overlapping interval. So we will simply increment the result by 1. We dont need to remove the interval because we only need to count the number of intervals removed.
5. So now the question how we remove the interval and move on to the next. We compare the previous end with the start of next interval. We are keeping track of the previous end of the interval in a variable. So basicallly we need to simply update the previous end. But how? We have to keep the keep the interval that has the smaller end. Because the interval with the larger end might be overlapping with the next interval. So we will simply update the previous interval with the minimum of two ends.
6. If the intervals are non-overlapping, then we update the previous end with the current end.
7. Outside the loop we will simply return the result. The time complexity of this solution is O(nlogn) because of sorting the list. The memory complexity is O(1).
