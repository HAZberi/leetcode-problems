**Notes:**

1. The problems asks us to find the query results from the given set of intervals such that query falls into the interval `left[i] <= query[j] <= right[i] `and also the size of interval `right[i] - left[i] + 1 `is the minimum of all valid intervals.
2. Lets discuss the brute force way of solving this problem. We will be needing a nested for loop. We will go over each query and for each query we will iterate over all the intervals. We will check whether the query falls into the interval. If it falls into the interval, we will update the size by taking the minimum of current size with the size of interval. Once we have gone through the inner loop of intervals. We will have the minimum size. So we will simply add the result of the query to the output list. Then we will continue to the next query and repeat the process. Since we are doing a nested loop, the time complexity of this solution is O(n.q) where n is the number of intervals and q is the length of queries. Can we do better? Yes.
3. The optimal solution to this problem is a bit tricky and complex to come up with and code. It improves the overall time complexity of the solution from the brute force. We do need to use multiple data structures, sorting the input and a lot of conditional. The final time complexity for this optimal solution is O(nlogn + qlogq). The space complexity is O(n).
4. The most important thing to solve this problem optimally is to draw a number line and see the input intervals and queries in sorted order. Once the inputs are sorted we can move from left to right and process the query results. This will help us in traversing the inputs only once from left to right as opposed to using a nested loop. We will sort the intervals based on the starting value.
5. Since we are sorting the inputs, the result that we need to return should be in the same order as the orginal order of the input queries. So, we will store the result of each query in a hashmap, once we have all the results in the hashmap. We will then use the hashmap to create the output list in the same order as the original order of queries.
6. We will also use a minHeap to keep track of the intervals with minimum size. In a minHeap we can acess the minumum value at the 0 index in O(1) time. However, pushing to the minHeap is just O(logn) time. We will not only push the size of the interval, we will also push the right value of the interval as well. So basically a pair of size and right value. The right value helps us in finding whether the interval is valid for the given query. So thats how the heap will help us in finding the valid interval with the minimum size for the query.
7. So we will loop over the sorted list of queries. We will maintain an i pointer outside the scope of this loop for intervals. Inside the loop we will keep on adding the intervals in a loop to the minHeap only if i pointer is in bounds and the left value of interval i is smaller or equal to the query value. We will push the size of the interval and the right value of the interval as pair in the heap. Once an interval is added, we will also increment the i pointer.
8. Now the question is how we are going to pop values from the heap and get the result for the query. We cannot simply get the minimum value from the heap and set it to the result. It might be possible that minimum size value interval is not even a valid interval for the query. We have only added the intervals, we never removed anything from the heap. It is totally possible that we might have added all the intervals to the heap just for this query. If we simply pop the minimum it will only give the correct result for the current query. What about the remaining queries?
9. So we need to check whether the minimum value is also a valid interval for this query or not. That's why we have the right value as well. We will simply keep on poping the invalid intervals in a loop by checking if the minHeap exists and right value is less than the query value. As soon as we find a valid interval with the minimum value we break out of the loop and add the interval size to the result. It is possible that there are no valid intervals in the heap, in that case the minHeap will be empty. So if the minHeap is empty after poping all the invalid interval, we set the result for this query to -1 in the hashmap.
10. Finally, when we have found the results of all the queries. We go over the original queires list, for each query we look up its result in the hashmap and append that result to the output list. Once we have created the output list. We will simply return it.
