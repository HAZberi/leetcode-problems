**Notes:**

1. The problem asks us to find the minimum number of conference rooms needed to arrange the meetings if the meeting duration is given in a list.
2. The first thing we have to realize that we are not looking for conflicts here, we just need to find out the maximum number of meetings happening at any point in a time. This would be our result.
3. The algorithm we can use here is that, if a meeting has started then we will check the next event in time, meaning it could be the end of this meeting or start of other meetings. So whenever a meeting starts on the timeline we will need a room, so we will increment the room count. And whenever a meeting ends on the timeline we are not required to have a room, so we will decrement the room count. So the room count starts with 0 and once the timeline ends the room count will be back to zero. We need to keep a result which records the maximum number of rooms required at a given point on the timeline.
4. Now lets find tune this algorithm, so we can code it up. According to the algorithm, start times will increment the room count and end times will decrement the room count. So we will seperate the start and end times in two seperate lists. Also we will sort the lists becuase we need to move over the timeline and take actions based on the events.
5. We will also keep a count variable which will start from 0 and a result variable that will keep track of the maximum count at a certain point in the timeline. We will need two pointers, one for the start time list and one for the end time list. We only need to go over the start time list becuase the maximum count can not be calculated if the only thing that is remaining to process is end times, since end times only decrement the count, so as soon we reach the end of start times list, we will have our result of minimum meeting rooms.
6. At each step in the loop we will compare the pointers, if the starting pointer is less than the value at the ending pointer, we will increment to the count and we will also move the pointer by 1. If the starting pointer is greater or equal to the ending point, we will decrement the count and we will also move the ending pointer by 1. Once we have gone thorugh this condition we will update the result by taking the maximum of current count and the previous result.
7. The time complexity of this solution is O(nlogn) becasue of the sorting. The memory complexity is O(n) since we have a list of start and end times.
