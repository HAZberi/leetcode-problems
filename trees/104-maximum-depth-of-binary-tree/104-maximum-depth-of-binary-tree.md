**Notes:**

1. This probelm ask us to find the depth of a binary tree, where number of nodes along the longest path is equal to the depth of tree. So it there is only one, the depth will be one.
2. This problem can be solved by 3 different approches. Recursive DFS, BFS, Iterative DFS. The type of DFS is preorder but with some modification.
3. Recursive Depth First: So preorder DFS is where we process the value first and then go to the left subtree and then go to the right subtree. So if there is no curr/root node we will simply return 0, no node = zero depth. This will be our base case. The recursvie case is where we calculate the depth. The depth of current node is 1. If we add the maximum depth of left sub tree and right sub tree. We will have the depth of this tree. `depth = 1 + Max(depth-of-left-subtree, depth-of-right-subtree)`
4. BFS: So BFS will be used as it. Only we have to start a depth variable before the start of the outer loop and once we get out the inner loop, we increament the depth by 1. Then simply return the depth.
5. Iterative DFS: This solution modifies the iterative DFS. In normal preorder DFS, once we process the curr value first, then we add right node to the stack if exists. Then move the curr to left. And once our curr is null then we pop out from the stack and set it as current. But in this case we just want to calculate the depth. We will use a stack with a pair of values (node, depth). We populate the stack with root and depth one. Then start looping over the stack. Preorder DFS means we pop out the value from stack. if the node exist, first we will take the max of current node's depth with prev depth, then we add its right and left children with depth +1 on to the stack. So each time we pop out a node from stack, we update the depth and add its left and right children on to the stack. If we pop out a null node then we will not add the children on to the stack.
