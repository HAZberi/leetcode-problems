**Notes:**

1. The problem ask to find out whether we can jump from the first index of the array to the last index. Each value in the array represents how far we can jump. It is important to remember that we can also jump less than the value.
2. There are two ways to solve this problem, first is the DP approach with stems from the brute force way. The second is the greedy approach will result in a more optimal solution to this problem.
3. Brute force approach is that from each index we can jump to 0 - value(nums[index]), meaning at each index we have the value number of choices. If we simply go with this approach the solution will O(n ^ n). But by looking at the decision tree, we can see that we can cache the result at each index, which can bring down the time complexity to O(n ^ 2).
4. If we try to solve the problem is Bottom Up DP. We can start from the end. Maintain a dp array as cache and have the same length as the given list. We can set the last value in the dp array to True. Becasue last index is already our goal here. Then for each index, we will go to every next index till the farthest index that we can reach to.. and check any of those indices in dp array return True. If any index return true then for the current index we set it to True as well in dp array and then simply move on to the next index. Note: I solved this question by using this strategy on the leetcode after looking at the problem first time and got it accepted. This solution is accepted by leetcode but its not the most optimal soltuion.
5. For the greedy solution we have to think the last index as the goal post. That's where we want to reach. We start from the last index and move backwards all the way to the starting index, same as we did in the Bottom Up DP approach. But here we try to move our goal post all the way to the starting index. If our goal post is at the starting index by the end, we return True otherwise we can return false. This is a O(n) solution. because at each reverse iteration we only move the goal post which is simply an O(1) operation.
6. But when and how we move our goal post. If we add value at the current index to the current index, it represents how far (index) we can reach, it doesnt really matter whether we jump one step or two step, the thing that matters that we can reach to that index. So, going backwards, if the farthest distance from an index is greater or equal to the goal post, it means we can reach to the goal post. So we update the goal post to the current index.
7. To return from the function we simple check whether the goal post is equal to 0. Since 0 represents the starting index.
