**Notes:**

1. The problem asks us to find the correct order of characters in an alien language. We are given a list of strings which is sorted in lexographical order. It means if we compare two consecutive words from the list, the first character where both the word differ tells us the order of characters (which character come before). For example, comparing two words w1 = "ape", w2 = "apple". The third character differs "e" & "p". It means "e" comes before "p". We can assume as if there is a directed edge that goes from e -> p. There is one edge case, that is specifically mentioned in the problem statement. What if the two comparitive words are w1 = "apple" w2 = "app" in this order. Basically the smaller (in length) word is the prefix of the larger word, we can see "app" is the prefix of "apple". This will mean the given list of strings is Not correctly sorted, so we should return "".
2. The problem poses an ordering issue of characters, we need a final string that has all the characters that are in the given list, in their correct order. Whenever we encounter an ordering issue, where we are able to find order between any two entities/nodes/characters and are required to find the overall any correct order between all the entities/nodes/characters, we make a graph which is a data structure and then apply the topological sort algorithm.
3. For this problem, it is important to revise topological sort algorithm. This algorithm can make use of both DFS and BFS appraches. But here we will use Post-Order DFS, marking nodes along the current path as we move through the graph, since this will help us detect cycles in the graph. Post Order DFS means, we process all the neighbour nodes first or leaf nodes first and then finally process the root. This will give us the correct order of nodes but in reverse order, so before returning the result we make sure we reverse the resultant order.
4. For this problem, the first step is to create an adjacency list, where we have all the characters as nodes/keys and values will be a hashset of neighbouring charcters (all the character that comes after the key/source/node character). Use a nested loop to create all the nodes/characters and map them to a hashset. We are using hashset because we dont want to have any duplicate characters. Then we will populate the adjacency list, by going over the given list and take two consecutive words (i and i+1) in each iteration. After that check whether the length of first word is greater than the second word AND the second word is the prefix of the first word, if so return "" right away. Otherwise we continue to build the adjacency list. Then we compare both the words character by character, as soon as we hit a letter that is not equal, we add that character of second word to the neighbour list of the character of first word. After that we simply break this inner loop.
5. Please refer to the implementation of topological sort. Usually we keep a path hashset and a visited hashset. The former is used to keep track of the nodes along the current recursive path, if we see a same element in the path hashset, we have detected a cycle. If this happens, we will return empty string. The visited hashset is used once we have processed the node and add it to the result, so if we encounter the same element/node again we simply return. But here we will use a slight different approach, instead of having separate visited and path hashset, we will use a visited dictionary. If the element is visited only, we set its value to False and if the element is in the current path we set the element to True. If our DFS function returns True, it means we have detected a cycle and we can simply return "". Otherwise we continue to add characters to our result.
6. The time complexity of building an adjacency list O(n * l) where n is the number of words and l is the length of each word. This will also be the overall time complexity of this solution as well. Because the time complexity of topological sort is O(E + V) where E is edges and V is nodes. In this problems we have a constant number of character i.e. 26. So run time of topological sort is O(26). Space complexity is O(26^2) since we build a graph using nested loops. The maximum character are 26.
