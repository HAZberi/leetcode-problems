**Notes:**

1. The problem asks us to find the cheapest cost to fly from a given source node to destination node with at most k stops. We are given a list of flights like so [src, dst, cost].
2. Just by simply looking at the inputs and reading the question, we can identify this as a graph problem, but there is one issue. We are required to find the cheapest path but with k stops. Intutively the first thing that will come to mind is to use Dijkstra Algorithm and somehow modify it for k stops. We can find shortest path to any node in Dijkstra but shortest path to any node with k stops is a different story. Why? What if we cannot reach a node in k stops, what if the cheapest path takes k + 3 stops but there is a valid path in k stops, it is expensive but there is a path. Dijkstra's algorithm always try to find the shortest path to the node in the graph. Yes it will be possible to modify Dijkstra and make it more about k stops then find the minimum. But a better approach would be to select an algorithm that goes layer by layer, much like BFS, that would be more suited for the k stops constraint.
3. Luckily there is an algorithm that solves this problem, it takes more time than Dijkstra, but is more adept to this problem and easier to code and understand. Bellman Ford Algorithm, it says to find the shortest path/cheapest cost to n nodes from a single starting source, we need to relax the edges n-1 times. There are two follow questions that arise from this statement:
   1. What do we mean by relaxation of edges? It means, if the distance to reach the source of an edge plus the weight of the edge is less then the distance to reach the destination. `distance[u] + cost < distance[v]`. Then the distance[v] should be updated like this. `distance[v`] = distance[u] + cost. Updating the distances this way is also known as relaxation of the edges. We have to do it for all the edges. Now the question is if we have to do this relaxation for all the edges, then we must know all the current distances to reach a node. For that we will initialize an array of size n. where n is total number of nodes in the graph. Then set the source node's distance to zero, because we start from here, for all the other nodes, distances has not been found yet, so we set all the distances to float("inf").
   2. Why n-1 times? Because we start from a source node, we already know the distance to reach here, which is 0. To find distances for all the remaining nodes, one node at a time, at most we have to relax edges n-1 times, if its a linear graph. It is important to note here that we might be able to find distances for all remaining nodes before relaxing edges n -1 times, if there are multiple branches in the graph. All the neigbouring nodes get their distances updated in a single iteration of edge relaxation.
4. The algorithm discussed above clearly shows that using this algorithm will be more beneficial for finding the cheapest with k stops. Here in this problem, at each edge relaxation we get the cheapest distance to a neighbour node, k is basically the number of nodes between source and destination. So k=0 at the source node, then we have k stops, after k stops the next node is our destination node. So in this problem we have to relax the edges k + 1 times. We need to know the cheapest price to destination at k + 1 levels.
5. Follow Up Question: If we are going through all the edges, then why it is called Layer by layer BFS. The answer is in each iteration the only distance we can update are the distances of the neighbours, the distances for the rest of the nodes in one iteration remains the same.
6. We initiate a prices list and intialize all the values to float("inf"), and set the value for the source node to 0. Then we have to relax the edges k+1 times, meaning we have to go through all the edges k + 1 times, compute the distances based on the current price list and store all the results in a temp prices list. Once we have all the updated distance in the temp prices list, we set the current price list to this new temp prices list. So each time when we start relaxing the edges we create a copy of current price list, then performs all the updates on the copy list and once we are done we assign the copy back to the original list.
7. If a destination node is accessible in k stops, the price at destination node will not be infinify. If price at the destination is inifinity it means we are not able to reach the destination in k stops, in which case we will return -1.
8. The time complexity of Bellman Ford Algorithm is O(E . V) where E is edges and V are vertices. But here we are only running the algorithm k + 1 times. So V is replace by k + 1. Since 1 is constant. So the overall complexity of this problem si O(E . k). The space complexity is O(N) because of the prices list.
