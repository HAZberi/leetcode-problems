**Notes:**

1. The problem asks us to find the minimum time if we start from (0, 0) and reach to (n-1, n-1) for given n x n matrix. Each value in the matrix represents the elevation. We can swim from (0, 0) to (n-1, n-1) in zero time if all the cells along a path are flooded.
2. There are few observations we will have to make while solving this problem. First we should identify as a graph problem we have been given a grid. Then since its rising water, it means for each + 1 rise in elevation  happens in 1 time. So it means elevation and elapsed time are same. The other way we can think each cell represents the amount of time required to fill this cell. So in order to reach the bottom right corner, we need a path that takes least amount to fill up. Basically the minimum path cost. We know dijkstra's algortihm find the shortest path distance, here we can modify that algorithm a bit and use it for minimum path cost, we know that the given matrix is unweighted but here the weight factor is the maximum value along a path from top left to bottom right corner. From these maximum path vales we take the path that has the minimum max-value of all the paths that lead to bottom right corner.
3. We are using a slightly modified version Dijkstra and BFS. Like Dijkstra we will use a minHeap, to pick nodes that has the minimum value among the neighbours, this way we will always pick the neighbours that has the minimum value. But hold on, is minimum value refers to the value of the cell or is it something else. According to the above statement, we have to find all the paths maximum value and then take the minimum from those. So from heap we can pick the minimum node with current path maximum time/height, So for each node that goes into the heap, or we can say the weighting criteria of our min heap, current path maximum. Whenever we pop from the heap, we will have a node with least current path maximum, or also in other words node on the path that takes the least time to fillup.
4. For this algortihm our setup is have the length of the grid. A visited hashset to keep track of the cells that we have been visited and add to the heap, so we can make sure to not add them again. A minHeap, which is a primary data structure here. We intialize the minHeap, with three values. (maximum path value till this cell, row number, col number). We initialize our heap with (0, 0, 0). We also intialize our visited hashset with (0,0).
5. So we run a while loop until minHeap becomes empty. The first thing inside the loop is to pop the element from the minheap. First value is maximum path value, second and third are the coordinates of the cell.
6. Then we write our termination condition basically saying whenever we reach the bottom right corner we will return the maximum path value. This will be our only return condition, because we are guarenteed to find a solution.
7. Now we go through the neighbours, pretty much similar to the way we traverse in the regular BFS. We will have a global neighbour's list. Then we go over that list and add the current nodes row and col to find the exact neighbour. Then we have to check two things, the neighbour should be in bounds and it should not be part of the visited hashset. If its not, then we add thiis node's coordinates to the visited hashset. Also we need to add this node's information to the heap as well. So for maximim path value, we take the maximum of max path value of current node and the neighbour node cell value. This will ensure we are not sending the value to the heap but we are sending the maximum time required to fill this cell.
8. Thats it we return our guranteed solution whenever we reach the bottom right cornes. The big o complexity of this problem is the same as dijkstra. E.logE => V^2LogV^2 => N^2LogN^2 => 2. N^2LogN => O(N^2LogN) where number of edges is less than equal to the square of number of Vertices/Nodes/Cells. E <= V^2. In this problem we have N^2 cells since we had n x n matrix.
