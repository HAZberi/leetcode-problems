**Notes:**

1. The problem asks us to construct an itinerary in a list from a given set of indivual tickets. Each ticket has source as 0-index and destination as 1-index. All the itinarary should start from JFK and the itinerary list should be in smaller lexical order.
2. It is pretty evident from the problem with list of edges given that its a graph problem, and we have to find a valid path and we have to keep track of the nodes on that path in a list. There can be multiple paths, so we have to also find a way to arrange the resultant list in lexical order.
3. Since we have the list of edges, we will first make an adjacency list. We loop of the tickets list and make an adjacency list of neighbours for each node in the graph. But before that we should sort the tickets list because we need the first path to lexically sorted. This way the neighbour's list is also sorted and then our recursive calls will be according to sorted order.
4. Then we will intialize the result with the source from where our itinerary start. So we will append "JFK" to the result list.
5. Then we are traversing the graph using DFS becasue we need to explore all the paths. So what should be our base cases:
   1. How we know that we have found a path. If the length of result is equal to the length of tickets + 1. That means we have found a path and we can return True. Why tickets + 1? Because our result starts with the source value "JFK". Then we visited all the edges/tickets that why + 1.
   2. After than we will check if the current node has no neighbours, meaning the adjacency list is empty. In that case we will return False, because we have already checked first that have we found a valid path. Now the only possiblity of node having zero neighbours is that its a dead end and we cannot complete the path. So in that case our recursive function should backtrack.
6. After that we will have our recursive case and backtracking as well. We need backtracking because if we were not able to find a path then we will come back and try a different path.
7. So we go over the neighbour list of the current node. It is important to know that we might be modifying the adjacency list by poping values that we have visited in the path. So its not a good idea to loop and pop the same list at a time. So we should make a temp variable and use a copy list to iterate over and pop values from the original adjacency list.
8. The first step is add this current value to the result and then pop it from the adjacency list. ProTIP: we have to also keep track of the index, because we will have to pop from a specific index. After we call the recursive function, our DFS return a boolean. So if our recurisive call returns true we, it means a path exists and we should also return True from here.
9. Now, we will do the backtrack, because our DFS returned false. So we should insert the same neighbour at index i in the original adjacency list and also we should pop the last added value from the result list. Then we simply move to next neighbour and check whether there is a possilbe path.
10. Once we have processed all the neighbours and haven't find a path, we should return False. We would have return true directly if we have found a path. So final statement is to return False.
11. Outside our recursive dfs method we will simply return result list after calling the DFS method with the source node "JFK" as an argument.
12. The time complexity of the solution is (E + V)^2. where V^2 is the total number of edges. So it will E + E^2, rounds down to O(E^2). And the space complexity can be taken from adjacency list which is O(E) and this is the same for recursive stack as well.
