**Notes:**

1. The first step in this problem is to get rid of the edge cases. The length of string s should always be equal or greater than length of string t otherwise just return an empty string.
2. The most brute force way to approach this problem is a sliding window. But first we count the frequencies of string t in a hashmap. Then for each element that we insert in our window, we have to check all the entries of the string t frequency hashmap. Since we are doing this entire check for each n every entry till we get to a valid window result. Where we update the result and increment the left pointer of the sliding window. This will give us O(m x n). Where n is the length of t and m is the length of s.
3. So basically the brute force approach is doing too many redundant comparisions. We can minimize the comparisons and can achieve an O(m) solution. So similar to the brute force approach we count the frequencies of the string t. Then we will have two variables `have = 0` which is the number of matches we have in our current window. And the second variable is need `need = len(t frequency hashmap)`.
4. We will also have two variable to update the results, an starting index and an ending index of the valid window. The second to store the length of resultant string. Note that we have to find the minimum string here.
5. We start our sliding window and add elements to the hashmap along with there frequency. Then we check where the added element exists in string t hashmap and it count is also equal. If so, we increment our have count by 1.
6. Then after each addition we have to whether our 'have' count is equal to 'need' count. We have to check this condition in a while loop. Because it is not necessay that if we remove the element from the left, we would always get invalid window. After dropping the value on the left, the window can still be valid and even shorter because the element we dropped could not be present in string t frequency hashmap. Basically after removing the left element 'have' count and 'need' count can still be equal.
7. First in this while loop we update the results. Only if current length of window is less than the resultant length. We then update both result variables.
8. After that we decrement the count of left elment in the window hashmap. Then check whether the current left element is in t string hasmap and its count is less than the count in t string hashmap. If it is, then we decrement the 'have' count by 1. Lastly, we increment the left pointer.
9. We return the string slice of resultant starting and ending indices, if the resultant length is not equal to positive infinity , otherwise simply return an empty string.
