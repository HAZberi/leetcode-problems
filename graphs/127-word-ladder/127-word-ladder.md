**Notes:**

1. The problem asks us to find the shortest transformation sequence from a given beginword to a given endword. We are given a wordlist of sequence, where each adjacent word only differs by a single letter. The beginword is not in the list but endword is in the list. Also note that the length of all the words is same.
2. The intution to solve this problem is identify that its a graph problem. How? First of all its a sequence where each word differs by a single letter. We have to find the shortest path from the beginword (which is not in the list). Just by looking at the example, we can tell that beginword differs by one letter in x number of words in the wordlist. So the x number of words can be the neighbours of the beginword. Then we pick the first word and identify its neighbours (all the words in the wordlist that differ by a single letter.). Basically there is an undirected edge to the neighbours. For example:  log -> dog and log -> cog. So log has two neighbours -> dog and cog. While dog and cog has log as their neighbour.
3. So it is important that we should build an adjacency list. Once we have an adjacency list built up. Then we can run BFS to find the shortest transformation path.
4. How do we build an adjacency list? The naive way is to take each word and compare it with every other word and match each character. If word differ by one character we add it to the neighbours list. This will be O(n^2. m) operation. Where n is the number of words in the wordlist and m is the  number of characters. Unfortunately, this way of building the adjacency list is not accepted by leetcode. The alternative way is a bit tricky. First we will have to create all the possible patterns for example: `hot -> *ot, h*t, ho*`. Then append the word to all of it's possible patterns. That's how we get all the neighbours matching a pattern. Since for each word, we have to go through all the characters "m". We will endup making "m" number of patterns, so this will be m^2. And we are creating patterns for all the words "n". So the time complexity of this operation is O(n.m^2).
5. We can also catch an edge case, if the endword is not in the wordlist, we can simply return 0.
6. Once we have successfully built the adjacency list. We can run Graph BFS. We will keep a visited hashset, so we dont process the words/nodes we have already processed. We also need a queue which is a requirement of BFS. We start with result[shortest path] = 1 because we will only run BFS is a single word exist. We will increament the result by one, once we have processed the entire level and before moving on to the next level.
7. How do we append the neighbours and what will be the termination condition? We take the snapshot of queue, which identifies a single level. We popleft a word. Then we check whether this word is equal to the given endword. If it is, then we simply return the result. If its not the endword, then we will add its neighbours to the queue. First we go through all the characters of this word in loop and create patterns. Then for each pattern, we go over the list of neighbours that pattern has, from our neighbours (adjacency list). For each neighbour word we will check if its visited, if not visited then we add it to the visited hashset and also append it to the queue. Since we have to go through all the edges. Number of edges in a graph is n(n-1)/2. Which will take O(n^2) and we also have to check all the possible patterns "m". So the time complexity of this operation will O(n^2.m)
8. Outside BFS while loop. We will return 0. If have found a path, we would have returned it right away. But if we have traversed the entire graph and havent find a path. We will return 0.
