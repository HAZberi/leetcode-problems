**Notes:** 

1. Given a matrix of size (m x n). The problem asks to find the nearest distance to the gate from an empty room. Each room is represented by an infinity distance, which we have to change when we find the nearest distance. A wall is represented by -1, which means this cannot be part of the path to the gate. A gate is represented by 0. If there is no path to the gate from an empty room, we can leave or skip that cell with infinity distance.
2. A DFS solution is possible, where we find all the paths to all the gates and pick the nearest path. But such a solution will have a very high time complexity of O((m x n) ^ 2). Since the problem is specifically asking for a nearest distance, we should be able to implement an efficient solution with BFS.
3. So if we try to run BFS from every room, we wont be able to find the correct solution. If we try to run the BFS from Gates/Source we wont be able to find a solution as well if there are more than one gates. But if we run BFS on all of the gates in parallel we will arrive at an optimal solution. In parallel means all the gates are at same level when we start running the BFS.
4. So we start out by finding the bounds of the given matrix. Then we will use the visited hashset to store the rooms that we have already visited. We will also use initiate the queue right at the start because we have to populate the queue will all the gates before looping, popping left and processing cells. So we run a nested loop and add all the gates cells in the visited hashset as well as append those to the queue.
5. Before looping the queue. We initiate the distance variable to 0. This way all the gates at the first level will be automatically at distance 0, when we pop from the queue. This is what we mean by ruuning **BFS in parallel from the source.**
6. The we use two loops, first loop will keep track of at which level/distance are we at. In the second/inner loop we take the snapshot of the queue. We popleft a cell and set this cell's current value to the current distance. Basically modifying the given input matrix.
7. Now we have to check all the neighbouring cells of this current cell and add only the valid cells. We can go about ths in two way, use a helper method to add a valid neighbour to the queue. OR run a for-in loop on all the possible neightbours and check whether the cell is valid or not, based on the check we add or ignore the neighbour.
8. We increament the distance before moving to the next iteration of the outer loop. At the end we simply return the modified given input matrix.
9. The time complexity of this solution is O(m x n) and the space complexity is also O(m x n). We visit all the cells in the matrix at most 2 times.
