**Notes:**

1. The problem asks us to find an edge in a graph that is redundant and cause a loop in the graph. If there is a loop, it mean the graph is not a tree. It is guranteed that there exist an edge that is redundant. We have to return the last edge that causes the loop in the graph.
2. There are two approches to solve this problem and we will be discussing both the approches.
3. The first approch is less efficient and yeilds O(n ^ 2) solution. Basically we will try to build an adjacency list without redundant edges. For each edge, we will first check whether there is a path that exists from node1 to node2. If there is an existing path from node1 to node2 then we will simply return this edge. If there is no path between node1 and node2, we add both nodes to the adjacency list.
4. So How do we find the path? We can run DFS and supply it with a source and target node. We keep on checking the source's neighbours recursively. If at any recursive call source becomes equal to the target we will return true. We also need a hashset to keep track of the visited nodes along the path. If our base case doesnot execute then we add the source node to the visited hashset and then check for neighbours. We go through the neighbour's list (from the current adjacency list) and check whether the neighbour has not been visited yet along this path AND recursively call DFS on neighbour and target. If the result of these two condition returns true, then we return true from the DFS method - but before that we will also remove the source node from the visited hashset, meaning there exists a path. Otherwise we simply continue processing all the neighbours of the source node. Once we have processed all the neighbours, we remove the current source node from the visited hashset, since we have explored all the possiblities on this path. Then we will simply return False, meaning there is not path between the source and target.
5. The second approach is much more optimal and instead of going through all the edges and then for existing path for nodes. We make use of the union find algorithm. This solution will yeild a O(n) time complexity.
6. As we know, in union find algorithm, we take all the nodes as disjoint sets, where the each node is the root parent of itsself. Then we start merging  two nodes, by finding their root parents (that the find part). If their root parents are same, it means there are already part of the same group, its also detect cycle in the graph, and also a union is not possible. If root parents are different then we make the smaller root parent the child of the larger root parent. So thats why we keep track of the size of roots.
7. Here in this second approach, if two nodes can not be unionized, it means they are redundant and causes a cycle in the graph, so we will simply return the nodes as an edge. Remember we are guarenteed to find a solution.
