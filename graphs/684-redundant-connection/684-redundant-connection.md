**Notes:**

1. The problem asks us to find an edge in a graph that is redundant and cause a loop in the graph. If there is a loop, it mean the graph is not a tree. It is guranteed that there exist an edge that is redundant. We have to return the last edge that causes the loop in the graph.
2. There are two approches to solve this problem and we will be discussing both the approches.
3. The first approch is less efficient and yeilds O(n ^ 2) solution. Basically we will try to build an adjacency list without redundant edges. For each edge, we will first check whether there is a path that exists from node1 to node2. If there is an existing path from node1 to node2 then we will simply return this edge. If there is no path between node1 and node2, we add both nodes to the adjacency list.
4. So How do we find the path? We can run DFS and supply it with a source and target node. We keep on checking the source's neighbours recursively. If at any recursive call source becomes equal to the target we will return true. We also need a hashset to keep track of the visited nodes along the path. If our base case doesnot execute then we add the source node to the visited hashset and then check for neighbours. We go through the neighbour's list (from the current adjacency list) and check whether the neighbour has not been visited yet along this path AND recursively call DFS on neighbour and target. If the result of these two condition returns true, then we return true from the DFS method - but before that we will also remove the source node from the visited hashset, meaning there exists a path. Otherwise we simply continue processing all the neighbours of the source node. Once we have processed all the neighbours, we remove the current source node from the visited hashset, since we have explored all the possiblities on this path. Then we will simply return False, meaning there is not path between the source and target.
