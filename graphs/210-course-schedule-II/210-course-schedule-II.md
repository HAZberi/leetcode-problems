**Notes:** 

1. The problem asks us to find the order in which a student is able to complete all the courses. If a student is not able to complete all the courses then we will have to simply return an empty list. We are given a total number of courses and a list of pre-requsite pairs. Each pair's 0th-index is the course to take and 1st-index is its pre-requsite.
2. The first thing we have to recognize is that this is a graph problem and the pre-requisite list is basically a list of edges of the graph and the number of courses are nodes/vertices of the graph. So with this information we should create an adjacency list map, where keys represent the vertices/course i.e. courses are labelled as [0 - numCourses - 1]. The value of this map is the list of pre-requisite courses for this key course.
3. This problem is very similar to the LeetCode 207. But here this problem is solved by Topological sort using DFS. Technique used in both problems is very similar with a few minor changes.
4. Once we have built the adjacency list with the given information, we have to set the stage for the recursive DFS method.
   1. We need an output list to store the courses in order. This is our resultant list.
   2. We need a visit hashset, once we append a course to the resultant list, we need to make sure that we dont process this course again. So we add the course that a student is able to complete in the visit hashset.
   3. Our graph can have cycles as well. Meaning two courses depend on each other and hence its impossible for a student to complete all the courses. In order to detect a cycle we have to keep track of all the visited courses along the current path of our DFS method. So we use a cycle hashset we keep on adding courses while we exploring a single, once we reach the end of the single path (i.e. a course that can be completed or has no pre-requsiites) we remove that course from the cycle hashset. If course exists in the cycle hashset then we will simply return False. It means we have detected a cycle and we should simply return False.
5. In our recursive DFS method we first check if a course is in the cycle set. If it is, then we simply return False. Then we check if the course can be completed and is in the visited set. We simply return True. After that we add the course to the cycle set. Then we check all of its pre-requisites and make recursive calls on all of its prequisites. The chain will go on and on because pre-requisites can further have their own pre-requisites until we reach a course that has no prequisites or the courses is already completed or cannot be completed. If any pre-requisite course is unable to complete, meaning the recursive call returns False. We will immidiately return False right away. If we all the pre-requsites can be completed then it means that this course can be complete and then we have to return True outside the loop.
6. Before we return True, we have to do some clean up. We have to remove this course from the cycle set because now we have completely explored this single path. Then we add this completed course to our visited set. So if we try to run DFS on this course again, we immidiately return true because we have already processed this course. After that we will append this course to our resultant list. Once we have gone through all these step we will only then return True from this recursive DFS method.
7. Then as the last step we run this DFS on each and every course in order using a loop. If at any iteration the dfs returns False, we will simply return an empty list because a student is not able to complete all the courses. Outside this loop we return our output/resultant list.
8. Since we have to run dfs on all the courses/vertices and we will visit all the edges at least once. It means the time and space complexity of this algorithm is O(E + V) or O(pre-req + numCourses). The space complexity is O(n) or O(numCourses) since we store the courses in visited and cycle hashsets. Remember we drop constant when we calculate big O complexities.
