**Notes:**

1. The problem asks us to find the number of islands in a given grid of m x n. The island cell is represented by "1" and water cell is represented by "0". An island is a collection of contigious "1" cells in four directions (up, down, left, right).
2. First we need to make sure we dont have any edge case. So we check if the grid exits, if not then we simply return 0.
3. Now the most important thing in identifying an island, is to first check whether the current cell is an island or not. If the current cell is an island then we need to check whether its neighbouring cells are also a part of this island or not. Once, we reach a cell whose all neighbouring cells are water, we can safely say we have successfully found 1 island. Then we move on to the next cell and check whether this cell is already a part of an island that we have previously visited. If not, then we have found another island 2. Also if the next next cell is water, we dont do anything and simply move on to the next cell.
4. Basically we traverse the entire m x n matrix cell by cell. If we found a cell that is an island, we run a breadth first search algo on that cell and add this and all the neighbouring island cells to a visited hashset. The bfs will terminate when there are no more adjacent island cells. At this point we will increment our island count by 1. Then we move on to the next cell, if its an island cell (1st condition), not present in the visited set (2nd condition) then we run the bfs, otherwise we will simply skip this cell and move on to the next cell.
5. Pro Tip: We will be using a bfs helper function. We will need a queue for level order processing and we use the global visited hashset. We also need the bounds of our grid. We keep on adding the neighbouring cells to the queue and visited hashset untill a cell goes out of bounds, or if its already in the visited hashset, or if its not an island cell (water). If you need more in depth clarification on the bfs algo. Please check the solution and notes for 1091.
6. One interesting thing, which i wont dive into much deeper detail as of now, is that if the interviewer asks you to solve the question using the dfs algo instead of the bfs algo. This is quite straight forward. Instead of popping left from the queue when processing cells, simply pop right. We will get the solution implemented by dfs. A good idea is to simply replace the queue with a list, popping the right element from the list is O(1). The rest of the implementation will remain as is.
