**saNotes:**

1. The brute force solution of this problem is to do 3 level nested loop and go through all the possible pairs. But even then it very problematic to remove the duplicates. Removing the duplicates will requrie another data structure(Hashmap) and then conversion operations (tuple keys to list). Right of the bat, this problem is O(n^3). Not efficient. We can strive for a better solution that exists as well.
2. Whenever we pick the first of the three, we need to make sure the same number is not picked again, otherwise we will have duplicate triplets. It is possible that the same number appears later down the list. So in order to solve this problem we need to sort the input array. Sorting the array would be O(nlogn), which is efficient compared to the brute force solution. So we are heading in the right direction.
3. So when the input array is sorted, same numbers will appear consecutively, so we can check the previous value and if the previous value is the spame we can skip it.
4. So we pick a value, check its previous, if the previous is not same. We move on to identify next 2 values that will add up to zero. Here since the array is sorted we can use two pointers left(picked value +1) and right(last value of the list). If the sum of three is greater than zero we decrement the right pointer. If the sum of three is smaller than zero we increment the left pointer. Else we will arrive at a unique triplet. Add all the three values to the resultant array.
5. The important point here is that we have to aviod the duplicates even for the last two numbers of the three sum. Of course we need to update the pointers before the next iteration, since we are looking for all unique triplets. `[-2, -2, 0, 0, 2, 2]` lets consider this scenario, after adding the values to the resultant array we will increment the left pointer. But even now the left pointer is still at the same number. if we dont increment the left pointer further we will end up with a duplicate triplet. So after incrementing a left pointer, we will put a while loop and keep on incrementing the left pointer. If the current left pointer number and the previous left pointer number is same.
