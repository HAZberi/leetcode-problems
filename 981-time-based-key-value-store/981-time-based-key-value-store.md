**Notes:**

1. This problem is relatively easier to understand but a close attention is required to the constraints. Basically we have to create a key-value store with timestamps. Whenever there is a timestamp mention, it means that we have ascending sorting available that can be used to our advantage at some point in the algorithm.
2. So a key-value store means we are going to use a hashmap, where each key is mapped to a list of value pairs. Each pair is also a list where we store a value at location index 0 and a timestamp at location index 1.
3. The problem asks us to create a get and set function. The set function is intitutive, we just need to create a key in hashmap and append a pair of value and timestamp to the list of values. ProTip: We can use a defaultdict here but in this case we can check first if the key already exists in the hashmap, if no then we create the key and assigned it an empty list. Then simply append the pair. So setting a pair in hashmap is O(1) opreration.
4. The get function is where time complexity matters. First is the brute force approach. In order to get the value for the corresponding key at certain time stamp. We can simply run a loop over the list of pairs and check each timestamp and value until we find our pair. Otherwise, we returned the value of last pair added. If there are no values, then we simply return an empty string. This will be O(n) operation.
5. Since we know timestamps are strictly in ascending order. We can do a binary serach which will yeild a much better time complexity of O(logn). So we take out the list of value pairs and run the binary search. It is importatnt to note here we are looking for timestamps, whenever  the timestamp we are searching is greater or equal to the timestamp at the mid, we extract the value at that timestamp and store the corresponding value in our resultant. We are not searching for values.
6. ProTip: We need to check first if the values for a particular key exists in our hashmap store. We will get the key and if the key is not present then we will set the default value to an empty array. `self.store.get(key, []) like so. `
7. ProTip: We need the largest of previous times. So whenever we encouter a mid value less than or equal to the timestamp we are searching. We set our mid value to the resultant value. And only after that we change our left pointer. In the else condition, we just need to change our right pointer. This way we run the the complete binary search, even if we have found the value. But the code looks consice.
