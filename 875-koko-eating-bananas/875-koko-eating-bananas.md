**Notes:**

1. The most important thing to understand here is the problem and the constraints of the given inputs. Koko can at most eat all the bananas from one pile even koko can eat more bananas according to its speed k. k is the number of bananas koko can eat in one hour. The problem asked us to find the minimum number of bananas koko can eat per hour to eat all the piles before the gurard arrives.
2. The given constraint tells us that length of piles is always less than equal to the hours before the guard arrives. Which means in a situation where length of pile is equal to hours. The minimum k requied to eat all the piles in the given time is the biggest pile. So at most the k is equal max(pile) value. The possible minimum k will be 1, since 0 means koko is not eating. So with this information we know that we have to find the value of k somewhere in the range of 1 ... max(pile).
3. The brute force solution will be to visit each k value in the range and calculate the total hours to eat the piles. At any point total hours at current k value exceeds the hours by which the guard retruns, We simply move on to the next k value in the range. As soon as we hit a value k where total hours to eat are equal to the hours by which guard retruns. We return the k.
4. Since we are searching the value of k in a range. We can make use of an efficient algorithm like binary search.
5. The left pointer will be set at min k and the right pointer at max pile. Initial result k can be set to max pile, becuase this the maximum possible k value. We are running the binary search to find the minimum k to eat all the piles.
6. We calculate a mid value k. Calculate the hours for that k value. Then check whether calculated hours is less than or equal to guard hours. It means koko is eating faster. So, to find a slower k, we move the right pointer to k - 1. Then we update our resultant k by taking the min of current k with previous result.
7. If calculated hours is more than the guard hours then it mean at current k the koko is eating slower. So we move the left pointer to k + 1.
8. We keep on finding the key until the right or left pointer crosses each other. At this point we just return the resultant k.
