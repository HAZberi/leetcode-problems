**Notes:**

1. The problem asks us to find the words in the given list on a board (mxn) of charaters and return those in a list.
2. The first version of this problem used backtracking and we were only looking for a single word on the board. In this problem we have a list of words to find out on the board. If we follow the same recursive technique and do it for all the words in the list one by one. It will be highly inefficent. The time complexity of such a solution will be O(w.m.n x 4^m.n) where w is length of the word list, (m.n) is the size of the grid and 4^m.n is the DFS call in 4 directions. So there is a better way to implement this problem.
3. For the optimal solution we still need to run DFS on each cell of the grid. But if we store all the words in a prefix tree data structure, then we can run those DFS based on prefix. This will improve the time complexity of the problem.
4. First we will create a TrieNode and initialize the constructor with two properties, children hashmap and endOfWord boolean. Then we can make a method of the same TrieNode class to add the word to the Trie. The current node is the self node and then we will go over the word character by character and if the character is in the children then we simply update the current pointer. Otherwise will add the character as the children and then update the current pointer. Finally once all the characters are added we will the status of the current pointer to True.
5. Now we will start designing the findword method of the soltuion class. First we will create a root Trie node. Then we will loop over the words list and add each word to the Trie.
6. After that we take the dimensions of the board. A result HashSet, to make sure we dont have duplicate words in the output. A visit Hashset, to track which cells have been visited in the DFS, so those are not visited again.
7. Then we start writing the DFS function. The arguments of the DFS is the row and column index, TrieNode to traverse and word string containing the character that has been successfully processed so far. Once the word is complete, its status from the Trie turn True and we count add this word to the result hashset.
8. The first thing in the DFS is to check the bounds of the grid, whether the cell is in visit set or whether the character on the board exist in the children of the TrieNode. If any of the condition is true, we will simply return from the DFS.
9. Once we have a valid character on the board. First we will add its location to the visit hashset. Then we will update the node to children character. Then we add this character to the current word. After that we will check whether this node in end ofthe word. If it is end of the word then we add this word to the result.
10. After than we will run DFS in all four directions of the gird. Once the all four recursive calls are complete we remove the current cell from the visit hashset.
11. Now in order to call this DFS method on each of the board. We will use a nested loop and call the DFS on each cell passing in cell location, root node and empty string.
12. Finally before returning the result hashset, we have to convert it to a list.
13. The time complexity of this solution is O(m.n x 4 ^ m.n) and the space complexity is O(w).
