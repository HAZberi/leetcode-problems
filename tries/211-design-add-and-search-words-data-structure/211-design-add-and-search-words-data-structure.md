**Notes:**

1. The problem asks us to design a word dictionary data structure such that we can add words to the dictionary and search the word in the data structure. We have to return a boolean in search result basically simply check the existance of the word in the dictionary.
2. There word searching is not simple because we have a wild charater of  "." which can be any character in the range of (a-z).
3. This question is Trie question and Leetcode 208 must be done before attempting this question. Over here we will be implementing a Trie data structue and the only change will come into play is designing the searching mechanisim. Rest of the logic and code is pretty similar to Leetcode 208.
4. So our search method will be a depth first search, recursive because whenever we have an input character equal to wild card ".". We have to explore all the possiblities and the easiest way to do it is recursive. So initially we will start with a root node the we go over the word character by character in a for loop, where we keep track of the current index of the character in the string.
5. Then we will have two possiblites. A simple case, where the character is not a wild card ".". In that case we, will check the children, if the character does not exist in the children hashmap we will simply return false. Otherwise we update the curr node with children node. Outside the loop we will simply return the end word status of the current node.
6. Now lets discuss the recursive case. Basically when we hit a wild card "." We go over all the children of the current node. For each child we will make a recursive call by passing the next iterator (i + 1), because a dot is any character that we have already picked now we need to check the children. The children is at i + 1, and we also pass the child object as the root for our DFS method. The dfs method will return a boolean. So if the DFS return True, we will immidiately return True. If the DFS method return false we will simply continue to the next child. If all the children return False. Then outside of this children loop we will return False.
7. The argument to the DFS method is the iterator j and the root, from where we start the search. A minor optimization that can be done here is caching the results of DFS.
