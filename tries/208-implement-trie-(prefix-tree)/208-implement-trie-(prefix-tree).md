**Notes:**

1. The problem asks us to implement a prefix tree aka Trie. Tries are helpful in autocomplete words and spell checkers.
2. A Trie is a tree, where are root node can has a maximum of 26 children. The problem asks us to build the tree for lowercase english letter. So a maximum of 26 children for each node of the tree is possible. We are asked to create the data structure, insert a given word, search a given word and search a given prefix. Searching will result in either true or false, representing the existence of the word.
3. A hashmap can insert and search for a word in O(1) time. But we cannot search based on prefix in a hashmap. That's for application like spell checker and autocomplete search by prefix efficiently is required and this is where a prefix tree is really helplful.
4. So first of all we need to create a Trie Node. The TrieNode has two properties, a children hashmap (where a character is the key mapped to a TrieNode), and an endofWord boolean which is set to False initially. The endofWord property helps us in flaging the TrieNode as the end of the word.
5. Then we initialize the Trie data structure. The root node is set to a TrieNode in the constructor.
6. To insert the word. We will start from the root node. Then we go over the character one by one and check whether the character exists in the children hashmap. If the character does not exist in children hashmap, we will simply add the character in the children hashmap as the key and set its value to a TrieNode. If the character already exists in the hashmap, then we dont add anything. After executing this condition, we update the current pointer to the TrieNode of the character children, then move on to the next character. Once we come out of the loop, we simply change the status of endofWord of the current node to True, marking it as complete word.
7. To search the word. We will start from the root node. Then we go over the character one by one and check whether the character exists in the children hashmap. If the character does not exist in children hashmap, we will simply return False. If the character already exists in the hashmap, then after executing this condition, we update the current pointer to the TrieNode of the character children, then move on to the next character. Once we come out of the loop, we simply return the status of endofWord.
8. To search the startsWith of the word. We will start from the root node. Then we go over the character one by one and check whether the character exists in the children hashmap. If the character does not exist in children hashmap, we will simply return False. If the character already exists in the hashmap, then after executing this condition, we update the current pointer to the TrieNode of the character children, then move on to the next character. Once we come out of the loop, we simply return True.
9. The time complexity of search and inserting into a trie is O(n) where n is the length of word.
