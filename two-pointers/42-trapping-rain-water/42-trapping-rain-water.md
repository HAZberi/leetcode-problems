**Notes:**

1. First we have to observe that min height has the ultimate effect on how much water can be trapped. For example at index 0, there is no height on left, so at first index, no water can be trapped. This pattern continues later on as well. At any current index, the minimum between max left or max right height matters. Then if we subtract the current height from this minimum then we will have the amount that can be trapped at current height. `Min(MaxLeft, MaxRight) - Height[currentIndex]`
2. One important thing to consider here, if we have negative value after the difference. We disregard it since negative value water cannot be trapped.
3. Now the first solution requires us to create extra arrays, to store max left of each index (1), max right of each index (2), min of max left or max right(3), then subtract min from height at current input(4). The take the sum of the 4th array. Then we will have the our result.
4. The second solution is a quick one and is also with O(1) time space complexity as opposed to the first solution which is O(n). No extra arrays are needed but conceptually its the same thing.
5. In this approach we have left pointer at the start of the array and a right pointer at the last index of the array. We will also have to maintain the max left vaule and max right. So two of these tracking variables. Also, we need a result variable, where we add up all the trapped water.
6. Pro Tip: max left and max right variables are initailaized with value at starting and ending indexes. Because they donot have any actual left and right.
7. Now we check whether left max is smaller than right max, for the smaller one we increment (left pointer) or decrement (right pointer). We updated the pointers first. Now we know, we only have one left max or right max, we update the leftmax or right max by the taking the max of current (left max or right max) with current height. After that we simply need to take difference of height from (max left or max right) and at the same time add it to the result (res).
