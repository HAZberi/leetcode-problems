**Notes:**

1. We are asked to design a least recently used cache, meaning key-value pairs that are least used will get deleted in order to make space for newly added key-value pairs. The space is called capacity here. Whenever we add the key-value pair that has the same key, we update it or simply remove the old one and insert the new incoming key-value pair.
2. The program ask us to achieve a time complexity of O(1) when we get or put the key-value pairs. This means, we need a hashmap. This hashmap is basically our cache.
3. In our hashmap/cache we map the keys to keys and value to nodes. `{key: Node}` Why Nodes? We know we have to maintain some sort of order in order to keep track of which key-value pairs are least recently used and which key-pairs are most recently used. A Doubly linklist can be used to maintain the order between least recent and most recent key-value pairs.
4. Whenever there is a new key-value pair, we add it to the right of the list. If we retrieve a key value pair, we remove that pair from the list and put it again but at the right of the list. If the key-value pair we are adding to cache already exists, then we remove the pair and add the incoming key-value pair. Whenever we go over the capacity, the least recently key will be availble at the left of the list. We remove the left most node and also delete the the key from the hashmap to balance the capacity of the cache.
5. For the Doubly linklist we create a Node Class. This will store the key, value, pointer to prev, and pointer to the right. Then in the constructor of LRU cache, where we set the capacity and initiate the cache hashmap. We create two dummy nodes, left and right. We join their pointers such next of left points to right and prev of right points to left. This will help us in inserting values on the right, deleting least used from the left. ProTip: We are using doubly linklist, so we have access to prev and next nodes all the time.
6. We can remove a node from anywhere in the list. It may be the LRU or when we update pairs or when we get the key and change the position of the node. We can think of it as we have to delete the middle node. We get the prev and next nodes of the middle node. Set the next of prev node to next node and set the prev of next node to prev node.
7. We always have to add the key-value pairs to the right of the list to make it most recent. We can always access the right node. We can insert in the middle by getting the right node as next and get the most recent node from the prev of right. Then set prev of right node to the new node and set the next of most recent node to the new node and then set the prev of new node to most recent node and next of new node to the right node. Now the new node has become the most recent node.
8. In order to get the value of a given key. We first look the key in our hashmap if it doesn't exist we simply return -1. If it does exist in the hashmap, then before returning the value, we have to first remove this key-value from list and then add it to the list again to make it most recent.
9. In order to add the value to cache. We first look the key in our hashmap if it doesn't exist we create a new node. If it does exist then we remove it from the list and then create the new node. Once our new node is created we insert it in the list. After that we check the length of our hashmap/cache is greater than the capacity. If it is, then we access the least recently used node which is at the next of left of our list. We remove this node from the list and then also delete from the cache.
