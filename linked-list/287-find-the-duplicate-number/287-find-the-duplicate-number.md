**Notes:**

1. This problem is not an array problem, its basically a linklist problem. It can only be solved with linklist algorithm. One way to identify this problem is that it says nums length is n + 1 and nums has integers in the range of 1 - n. Meaning there will be no zero 0 in the integers. All the intergers are positive.
2. Can we create any links from one value to other. We know we cannot create a link to the first value which is at index 0 from anywahere in the list. That's the reason why nums length is n + 1.
3. We can think of the values in nums as pointer to the next index. So if, at 0 index the value is 3. This 3 actually points to the 3rd index. The 3rd index has a value 1. This 1 points to 1st index and so on. We dont hace to modify the array, we just need to think this array as a linklist in this case.
4. Once we figure out that this is a linklist problem and not an array problem. We can use Floyd's algorithm for cycle detection and finding the start of the cycle. Here we have another cue of that if linklist has a cycle, only one value will be repeated more than once and that vaue is the start of the cycle.
5. We start with slow and fast pointer both set to 0. 0 is the index of nums array. We keep the loop running in this case because slow and fast pointers cannot be null. because we are guaranteed to find a solution. Which means we are guaranteed to find a cycle. Since the value in the nums list points to the next index. We move the slow pointer once `nums[slow]` and fast pointer twice `nums[nums[fast]]`. Once slow and fast are equal we break out of the loop. It means we have a cycle.
6. Now we have to find the start of the cycle. We initiate a second slow pointer. The pace of this pointer and the slow pointer is the same. Again we keep running the loop. Move both the pointers and then check if second slow pointer and the inital slow pointer are equal. At that point we just simply return true.
