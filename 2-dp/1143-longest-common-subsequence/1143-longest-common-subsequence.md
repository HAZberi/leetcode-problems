**Notes:**

1. The problem ask us to find the longest common subsequence from the two given strings. A subsequence has to be in order but it may or may not be contigious.
2. The initution behind this problem is to go character by character and check if the character matches or not. If the character matches it means we can add 1 to the LCS, if the characters dont match then we will have two choices, 1) dont move the character pointer of first string and move one character pointer of second string 2) move the character pointer of first string and dont move the character pointer of the second string. This will create 2 branches, whenever we have unmatching characters.
3. So, the approach we are going to solve the problem first is the memoization of the brute force. Since we have a decision tree of 2 branches our time complexity of the brute force solution is O(2 ^ (m + n)). If apply memoization to the problem then the time complexity will O(m .n)
4. Our base case is whenever we reach the end of any string, ie. the character pointer becomes equal to the length of the string. At that point, its not possible to find any common subsequences further, so we will simply return 0.
5. The second base case is our caching case. Whenever we found a computed result for the character pointer positions lets i,j, we will return the cached resut.
6. Now for our recursive cases, we have two situations, if we have a matching characters we will add 1 to remaining LCS of both the strings.` 1 + LCS(i+1, j+1)` If we dont have matching characters then we will look to the find the LCS with two choices as discussed above. What if we find a common subsequence is one of the configuration of character pointers? So thats why we take the max of both choices. `max(LCS(i+1, j), LCS(i, j+1))`. We will have to cache both these results and then finally return the cached result for this configuration of character pointers.
7. The second solution that we will discuss here is the bottom up solution aka tabulation. Like in our memoized, here we will also store the results, but we will use a m + 1 x n + 1 grid. We will convert the logic of top down to this bottom up approach. On rows (i) we will have one string and on cols (j) we will have the second string. Now we are able to match character by character and we are also able to record the current LCS at the location.
8. If we are starting from the bottom right corner, in order to calculate its LCS, we must know the LCS when the character pointers are at strings length. This refers to the base case of top down, whenever we reach the length of the string we returned 0. Similarly here we made our grid m + 1 x n + 1, it means we will have to manually populate the grid to be zero, which will inculde the cells where character pointers are at length.
9. Now in order to calculate the LCS at i,j location in the grid. We have to first match the characters in ith row and jth column. If the charcters are matching then we will look at the result of the diagnal, add 1 to the diagnal result and we have the LCS for ith,jth cell. If the characters are not matching then we will have to look the result of the right cell and the bottom cell. Whichever is the maximum of right and bottom cells we make it the LCS for ith,jth cell.
10. Finally our result will found at the (0,0) of our dp 2d where we were storing the results.
