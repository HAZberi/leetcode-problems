**Notes:** 

1. The problem asks us to find the number of distinct subsequences in the given string s which are equal to the given string t. We can also say how many subsequence of s can make up the string t.
2. We are looking to solve this problem with the top down approach only, later on for better understanding of the problem we implement the bottom up solution on our own or at least try it out.
3. Let's analyze the most trivial cases first, these will help us in creating the base case. Following are the possiblities:
   1. If both strings are empty, meaning length of string t and length of string s is 0. Empty string is subsequence of empty string. So we will return 1. If our i and j character pointers reach the end of the string we return 1.
   2. If string t is empty but string s is not empty, or we can say that char pointer j is at the length of string t, while the character pointer (i) is not at the length of string s. We will return 1. Because we can still go to the situation in the above point. So if character j is at length of t, we return 1. If we combine the   point 1 and point 2. It means that if string t is empty or character pointer j is at the length of t. We can simply return 1.
   3. If string s is empty but string t is not empty, or we can say that the char pointer i is at the length of string s, while the charater pointer (j) is not at the length of string t. We will return 0. Because string s has no characters to make any subsequence with with string t. So in this case we will return 0.
4. Let's discuss the recursive cases, remember we are looking to calculate the number of distinct subsequence in string s. So we have to compare character by character. Then we will have two generic cases, and one special case.
   1. Both the characters at i char pointer and j char pointer are matching, then we can move both the char pointer by 1 to the next characters. So we will do (i + 1, j + 1) for the recursive call.
   2. Both the characters at i char pointer and j char pointer are matching, but we can skip the character at i char pointer by 1, because there is a possiblity that there might be another matching character that will match the charcter at j char pointer. So we will do (i + 1, j) for the recursive call. It is importatnt to note here that both points 1, 2 happens when the characters are matching, so we will add the results of both choices and that will be the number of distinct subsequences for string s and t up until the char pointers (i, j).
   3. If both characters are not matching, then we will increment the char pointer i of the string s and keep the char pointer j of the string t as is. So it will be (i + 1, j) for the recursive call.
5. As we can notice that, our results are dependent on where the (i, j) are? So we can cache the results and speed up the runtime complexity from the simple recursion approach. After our base cases, we should check the results in the cache and also save the results of recursion in cache.
6. The time complexity of this algorithm is O(m . n) because we have to go character by character and our cache is also of the same size O(m. n) where m is the length of string s and n is the length of string t.
