**Notes:**

1. The problem asks us to find the longest path in a matrix of size m x n such that the path is always increasing. We can move in up, down, left, right positions from the cell. A key observation of the given problem that there is no loop possible because the we are looking for an increasing path. The integers are in the range of 0 and up. Meaning only positive integers are allowed. This is important here because this information can be used to design our base cases.
2. The basic intution for solving this problem is that starting from each cell we have to find an increasing path and record the length of increasing path for each cell in the matrix. Once we have computed the lengths of increasing paths for each cell, we can simply take the maximum of all paths and that would the solution to this problem.
3. Now how can we find the increasing path at a given cell. In graphs we have two popular algorithms DFS and BFS. Here we can make use of the DFS algorithm to find the increasing path for each cell. From a given cell we are only allowed to move in four directions. An increasing path can potentially be present in any of the four directions. So intutively we have to check all four directions and make sure the direction is valid. Meaning the neighbour is in the bounds of the matrix and it should be greater than the previous/last cell, only then we increment the length of the path. This is a bad and termination base case. What information we need to execute this base. We should know the current row and current col index and also the previous last value to compare. So our DFS will have three parameters, row and col index - to locate the current cell in the matrix and the third parameter of previous value to compare whether we have an increasing path or not. If a cell is out bounds or its value is less than equal to the previous value, then the length of the path is 0 and we will simply return 0.
4. From our intution, we are looking to compute increasing paths for each cell. It would be a good idea to have a cache to store all those increasing paths. When we run DFS on a neighbouring cell, we can use the cache and get pre-computed result for neighbouring cell in O(1). This will make DFS more efficient and we only need to traverse the matrix only once.
5. Let's see how the recursive case works here. Each cell as itself only has a length of 1. So if we run the DFS on each cell, each cell should return at 1 as length. So we set the result to 1. Then we have to check neighbours, checking neighbours mean we make the recursive call on each neighbour with their row and col index and passing current value as prev Value. We also need to add 1 to this recursive call because the length of the current cell is one. Then we can simply take the max of previous result with this new result and we do this for all four neighbours. Once all four recursive calls are complete, we will have the resultant length for the current cell. So we store this final result value in the cache and return this value from the DFS.
6. It is important to note here that we need to run DFS on each cell. So we can use a nested loop to go over the entire matrix and run DFS on each cell one by one. The results will be stored in the cache for each cell. The previous value parameter value can be set to -1 because only non-negative numbers are allowed. Once we break out of the nested loop, we take the maximum value from the cache and return it.
7. The time complexity of this problem is O(m x n). For each cell we have to compute the resultant length only once and then we can use the precomputed result to compute the result for the remaining cells. The space complexity is also O(m x n), since we store the resultant increasing length for each cell in our cache.
