**Notes:**

1. The problem asks us to check whether a given input string "s" can be created with a given pattern string "p". The pattern "p" can have a "." that can be matched to any single character and a "*" that can be matched to zero or more instances of character that comes before it.
2. The intution to solve this problem is to find the bottleneck, which helps us in identifying that what type of algorithm we can use to solve this problem. We know if pattern "p" does not have any "*" or "." then we have the case of simple string matching. If the pattern has only ".", then it is also simple because "." can be matched to any character. The tricky part is when the pattern has an asterik, now we have some decisions to make, since we can repeat the preceding character 0 - n times.
3. For this case we have to draw a decision tree, whether we repeat a character or skip it. A good idea is to draw a decision tree using a good example where we are able to cover at least two to three basic use cases of the range. Skip the preceding character entirely because the preceding character is not present in the input string. Also, there should be another asterik which can be used at least 2 times because there are two consecutive occurences of the preceding character in the given input string. This should cover all the required basis on the use of asterik.
4. The use of decision tree and finding the cummulative result hints towards a dynamic programming recursive approach to solve the problem. We start with a simple recursive solution and then add caching to optimize the solution. Note: In this solution the time complexity of top down and bottom up approches is exactly the same. For simplicity we will discuss only the top down approach which should be enough for purposes of the interview.
5. First of all we need to iterators, i for input string and j for pattern. Initially both start from 0. Then for the recursive calls, all that matters is how we increment these pointers based on the decisions. Once we get to the end of both input string and pattern string. It means we have successfully matched the pattern with the given input string, so we will return True. This will be our termination base case and also the good base case. The bad base case would be if there are characters left in the input string to match `i<len(s)`, but there are no characters left in the pattern j >= len(p). Then we will return False.
6. Now lets discuss the recursive cases. First thing we should check is that the character at i pointer matches the character at j pointer OR the character at j pointer is ".". If there is a "." it automatically means we have a match. ProTip: We can store this result because we might need to use it if the next character in the pattern is asterik.
7. The we have to check whether the next character in the pattern is an asterik. If it is then we have two choices. Inculde it or skip it (recursive calls). If we decide to skip it, then we keep the i pointer as is but increment the j pointer by 2, so the j pointer is at the next character after the asterik. `(i, j + 2)` If we decide to include it then we have to check whether there is match between characters at i and j And if there is a match only then we will increment the i pointer by 1 and keep the j pointer as is. (We might need to use the asterik again, asterik can be used 0-n times) `match and (i + 1, j)`. We can take the OR  between these two decisions and return the result. This is how we tackle the bottleneck of this problem whenever the next character in the pattern is an asterik.
8. If the next character in the pattern is not an asterik then we just need to check it there is a simple string match between characters at the respective pointers i and j. We have already calculated the match at this  point. If there is a match then we make the recursive call by incrementing both i and j pointer by 1. `(i + 1, j + 1)` and return the result.
9. If there is no match and no leading asterik in the pattern, then we can simply return False at the end.
10. In order to optimize this solution, we can use a cache, a hashmap where keys are (i, j) input parameters of our DFS. We need to a base case for cache, if the result is in the cache, then we simply return it. And whenever we calculate a result we need to first update the cache and then return the result.
11. In terms of time complexity without memoization, we have two choices in the case of asterick and the decision tree can be maximum of height n. So the time complexity without memoization is O(2 ^ n) which is not efficient. But if we implement the solution with cache then the time complexity will be reduced to O(n.m) where n in is the length of input string and m is the length of the pattern.
