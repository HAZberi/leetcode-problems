**Notes:**

1. The problem asks to burst all the balloons in a given input array in such a way that we are able to collect maximum coins. At each balloon that is burst, the total of coins just for that one burst ballon is `nums[i - 1] * nums[i] * nums[i + 1]` coins. We have to add this factor for each balloon to get the total number of coins collected by bursting all the balloons. We have to find the maximum number of coins the we can collect by bursting all the balloons.
2. The brute force solution of this problem is that we can burst any balloon first and then we will be left with the remaining of the balloons. Thats how we will try to divide this problem. The remaining balloons will form a subarray and recursively calculate the coins and then it will be added to the current burst balloon coins, this will give us one way to burst ballons and collect the coins. We have to do this process n times, so we have calculated all the ways each time starting at a different index. Finally we will simply take the max. It wont be an efficient solution and might not be enough to pass on leetcode or even in an actual interview but its a good start. Even if we implement a caching mechanism with the simple recursive solution it won't be enough. [brute force application is explained here.](https://thewayofnada.medium.com/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f "Brute Force Approach")
3. The first main trick to solve this problem is to think about if we can divide the problem in a different manner. Clearly the brute force approach is not working, so what if we pop the ith element/balloon at last and first solve the left subarray and right subarray.
4. We solve the subarrays first and store the results of those subarrays in a cache. When both subarrays have been solved then we calculate the coins for the last remaining balloon and add it to the results of the subarrays. Then we update the cache for the current subarray. So instead of popping first, we will pop the ith balloon last, that will divide the problem more efficiently.
5. Two more important things to remember is that how we will build our cache and how we cater the out of bound nuetral value of 1. For the latter, we can modify the given list by adding 1 at the begining and and 1 at the end of the array. Then for our recursive DFS and computation, we will have a left pointer and a right pointer. Initially the left pointer will at index 1 of the modified list and right pointer is will be at len(balloons) - 2 index of the modified list. Our cache will be two dimensional, left index and right index of  the subarray (left, right index combination) is mapped to the number of coins. By doing this the space complexity of the solution is O(n ^ 2).
6. So the parameters of our DFS is left and right indices. If left pointer crosses the right pointer, it means there are no balloons remaining to burst, so we will simply return 0. The second base is for out cache. We can have either dictionary or 2D cache. Remember 2D matrix cache is more efficient performance wise. If the result of the subarray is already in cache then we will simply return the cache.
7. For the recursive part of the solution, first we will have to go through the entire subarray, value by value. We calculate the coins for the last popped index and save it. Then we recursively solve the left subarray and the right subarray and then add all three of these. This will give us the number of coins collected if the ith element is popped last.
   ```
   nums[L - 1] * nums[i] * nums[R + 1] + DP[L][i - 1] + DP[i + 1][R]
   ```
8. Then we need to update the result of this subarray in our cache by taking the maximum of current result and the previous stored result in the cache.
9. The time complexity of this solution is O(n ^ 3) since we have n ^ 2 subarrays to solve and for each subarray we have to go through all the values in the subarray. So n. n ^ 2 will give us O(n ^ 3).
