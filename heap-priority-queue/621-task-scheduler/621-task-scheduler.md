**Notes:**

1. The problem ask us to calculate the minimum unit of time required to complete a list of tasks, such that there is a cooling time n between two same tasks. One unit of time is required to complete a single task. So if we have two same tasks and cooling time is 2. It means we will do the first task, that took one unit of time, now we have to wait 2 unit of times. So when the unit of time becomes 3, we can add the second task.
2. A very appropriate intitution is to use the most frequent tasks first and then during the cooling time we use the lesser frequent tasks. If we choose the lesser frequent tasks first, we will end up doing unnecessary idle time. This will NOT lead us to the minimum time required to complete the tasks. So the first logical step is to count the frequency of tasks in a hashmap. Or we can use python Counter, which calculate the frequencies and put it in a hashmap for us. So we will use the Counter here.
3. In order to keep track of most frequent task, we will use a maxHeap. This maxHeap will contain the frequency counts of the tasks and as a heap property we can take the maximum value in maxHeap at O(1) pop. So we will heapify the frequecy counts. In Python, there is no maxHeap by default. So we have to multiply all the frequency with -1 and then build the heap. This will give us a maxHeap with negative sign. So when we pop from the heap, instead of subtracting 1 from the count, we will actually have to add 1 to the count. And as soon as count is zero. It means we have run all the task.
4. Now we also need another data structure, Queue. Once we pop a value from heap, it means we have executed a task. So the time unit is also increamented by 1. We also change the count by adding 1 in this case. But after that we are not allowed to execute the same task again until the cooling time has passed. So we need to hold that task with the updated count and the time when this tasks becomes available to execute. Think of it as that task execution happens for the values in heap and wait time/cooling time is handled by the queue. The time when the current task becomes available again is `current time + cooling time `
5. We keep on incrementing the time till we have values left in the heap or in the queue.
6. Once we executed a task, add its new count and availble time to the queue. We then check the queue if leftmost value in the queue has time equal to the current time. It means we have to add this count back to the heap. So we popleft from the queue add only the count value in the heap.
7. After the while loop we will simply return the time it took to execute all the tasks.
8. Counting the frequency takes O(n) time. Heapify the count values is also O(n) time. Then we did push and pop from the heap, this will 2 x log26. So the overall time complexity of this algorithm is O(n) linear time.
