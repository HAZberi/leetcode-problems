**Notes:**

1. The problem asks up to find the last remaining weight of the stone, if two heaviest stones are smashed together. If the two heaviest stones have same weight then both stones are destroyed, otherwise the lighter of the two stones will be destroyed and the heavier of the two will the difference between lighter and heavier stone. If no stones are remaining after the smashing then we will simply return 0.
2. The main bottleneck of this problem is to find the two heaviest stones in the given list. The most appropriate data structure that can be used here is heap and specifically a max Heap. Unfortunately python does not have support for max heap. So we have to use the min heap with a bit of a twist. If we multiply all the values of the given value with -1. Then we can find the max value at the root of the heap, we just need to pop it. It is important to note that the popped value will be negative, so we have either multiply it again with -1 or we can take the absolute of this value.
3. After multiplying the given list with -1. We call the heapify function, which will heapify the given list and we can access the max value by simply popping off from the heap.
4. Then we have to keep popping off the two max values (two heaviest stones) until the length of the heap is equal to 1. The heaviest is y, because x <= y, we will pop it off first and then we popped the second stone. Remember the values for these will be negative.
5. The we will simply check if x is not equal to y. In that case, we take the absolute difference of y and x and push it to the heap.
6. Finally we append a zero 0 to the heap, because if there are no stones left, then we just add a 0 to the list, which will be accessible at the root of the heap. By doing so, we can convinently return the 0 index of the heap.
7. The time complexity of this algorithm is O(n.logn) because popping from the heap is a O(logn) operation and we have to do it n times. While heapify is only O(n). So the worst case for this algorigthm is O(n.logn)
