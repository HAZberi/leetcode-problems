**Notes:** 

1. The problem asks us to find the kth largest element in an array. So if we we simply sort the array which is O(n.logn) operation and then the kth largest element would be available at `len(nums) - k` index.
2. The question ask us to solve the problem without sorting. So the next idea is to use a max heap. We put all the elements of the given list in a max heap. Then simply pop the heap k times. So building the heap is O(n) operation then we have to pop k times. Each pop is O(logn). So the overall complexity of such a problem is O(n + klogn). I have coded this solution myself and its also got accepted at Leetcode.
3. The third algorithm is a more intersting way to solve this problem and also its not just another, it is a better way in terms of average time complexity. We will use the algorithm **QuickSelect** which has an average time complexity of O(n) but the worst case is O(n ^ 2). But the worst case is only possible if the array is sorted.
4. We will be doing the QuickSelect algorithm in place by swaping the values. But before that we will find the index of the kth largest element if the the array is sorted.
5. We have recursively call the QuickSelect function, if we dont fint the largest in the first pass. We will keep on decreasing the array by selecting which portion of should we use to find,
6. The qucik select function take the starting and ending indices of the list. We set the value at left pointer to p and make the value at the right pointer pivot. Now we run a simple for loop from left pointer to right pointer. We will compare each current value with the pivot. The pivot helps us in such a way, that all the values on the left of the pivot are smaller and all the values on the right of the pivot are greater. So now we will check if current value is less than equal to the pivot. If it is then we swap the current value with value at pointer p. After the swap we increment the p pointer. If current value is greater than the pivot value, then we do nothing. Notice in this case the p pointer is not increamented. If any next value is less than equal to the pivot, only then we swap the value p pointer with that value, and only then we increment the p pointer.
7. Once we have found the partition based on the p pointer. We the swap the value at p pointer with pivot value. (the value at the right pointer)
8. Now we have to check whether the p pointer is greater than k. Running the quick select recursive with correct bounds. It means we have shift the right pointer to ` p - 1` and the left pointer will remain as is. Then we check whether the p pointer is smaller than k. We call the quickselect again recursively and shift the left pointer to `p + 1` and the right pointer will remain as is. If the p pointer is equal the k. Then we simply return the value at p pointer, which will be the kth largest value.
9. Finally, outside the recursive quickselect fucntion we will simply call and return the quickselect fucntion. The left pointer is set to 0 and the right pointer is set to `len(nums) - 1`
