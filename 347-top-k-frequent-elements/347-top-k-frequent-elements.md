**Notes:**

1. This problem demands the top most frequent elements in the list. For example: if k=2, it means we are looking for top 2 most frequent elements in the given list.
2. The first step is to count the number of occurances for each value in the list. Use a hashmap and calculate count for each value.
3. The first idea to simply do a sort in ascending on the values of the hashmap and then pop out k values. Since sorting is O(nlogn) at best. The solution is not optimal.
4. The second idea is to max-heapify the hashmap. And then pop out k times. Highest number pop out in O(logn) time. And we have to do it k times. Meaning in this case we have O(k.logn) time complexity which is slightly better than the sorting.
5. To improve the solution further and achieving O(n). We have to employ some inspiration from the bucket sort algorithm. Where values are represented as indices and the count for each value is stored as value.
6. For this problem, we create a frequency array that will have counts as indices. The length of frequency array is equal to the length of input array + 1. Because thats the maximum number of elements whose frequency information we have already calculated in the hashmap. The values in the frequency array is the list of all the input values having the same number count. Example: For count 3, index is 3. And for value the list is [3,6] since 3 and 6 apeared 3 times each.
7. To find the resultant array. Traverse the frequency array from the back, co and as soon as the length of resultant array is k. return the resultant array. Pro Tip: The traverse looks like a nested loop and might suggest that the time complexity is O(n^2). But its not, because we will be having n + n operations at most. At each iteration in the outer loop, we are not iterating n times in the nested loop.
8. Refer this comment: "Edit: Nevermind, I think I realize it now, I figured I would write it out for anyone who might still be confused. As we traverse through the array, we go through the whole array. So this is O(n). But we aren't doing an operation n times at each stop. We are doing N more operation throughout the entire array. So even though the for loops are nested, we are doing N more operations throughout a for loop which is N, so the total is just N+N, which simplifies to O(N)"
