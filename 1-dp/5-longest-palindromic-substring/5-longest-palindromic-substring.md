**Notes:**

1. The problem asks us to find the longest substring that is also a palindrome in a given string.
2. The most intutive way or we can say the brute force way to solve this problem is to find all the possible substrings, so for each character in the string, we combine it with all the remaining characters one by one. This operation would be O(n ^ 2). Since there are n characters, and for each character we can make n substrings. (think of a nested loop). But hold on, for each substring we also have to make sure that its a palindrome, only then we find the longest palindromic substring. So how do we find that a string is a palindrome. The most intiutive way of doing that is using two pointer. A left pointer at the starting character of the string and a right pointer at the ending character of the string. Then we compare the characters, if the character are not equal => we terminate and conculde that the string is not a palindrome. If both the character at left and right pointers are same, then we shift the left and right pointers inwards, increment 1 to the left pointer and decrement 1 to the right pointer and compare the new characters. This process takes O(n) time. So overall, finding substrings that are palindromes is a O(n ^ 3) solution.
3. Now the question is that can we do any better? Yes! We can bring the solution down to O(n ^ 2). For that we need to rethink the way we are finding palindrome and can we approach it in a dynamic programing style, we find the subproblems and keep compounding the solution to reach the final solution. The two pointer technique discussed above cannot fit to the dynamic programming style. But if we start doing the opposite we might be able to figure out sub-problems that can lead to the final solution.
4. If we put both of the left and right pointer in the middle instead of placing them at the ends, we will see that the middle word is a single character and its a palindrome because left and right pointers are equal. Now we move outwards, by incrementing the right pointer by 1 and decrementing the left pointer by 1. Now we compare the characters at left and right pointer. If the characters are same, we have a palindrome of length 3. If our comparison returns false we can conclude that the string is not a palindrome. So if we start, from the first character, consider it the mid of the palindrome and then move the left and right pointers outwards. We would be able to find the all palindromes of odd length. It is important to note that either pointers can go out of bounds, in which case we have to terminate the operation.
5. But hang on, we just found a way to find all the palindromic substrings of odd length. What about the even length palindromes, it is possible that the solution is tied with even length palindrome. So, we do the same process once again but with a small change. For odd length, we set both pointers to the single index and then moved outward. Here we set the left pointer to index 0, and the right pointer to index 1. Since we have two values at the start, we are on the right track to find the palindromes of even length.
6. Since we have to go through each character of the given string, thats "n". Then we find all the possible palindromic substring by keeping each character in the middle. that "n" as well. We will have a time complexity of O(n ^ 2). We have to do this process two times. First for odd length and second for even length. So overall time complexity is O(2. n ^2) which is better the O(n ^ 3) solution.
7. We dont only need to find the length of longest substring, we also have to return the longest substring. So we need to keep two global variables, a resLen varible and a res variable as a string. But the problem is if we keep upadating the res variable, we slice the orginal string at index left and right and store the copy in the res variable. This operation in it self is expensive and can make our solution O(n ^ 3), we dont want this. So instead of keeping a res variable as a string. We simply can store that left and right indices as pair in the list and keep on updating that if we find a new valud solution. At the end we can simply take the slice of the original string and return it.
