**Notes:**

1. The problem asks us to find the two partitions of the given list of numbers such that the sum of partitions are exactly equal to each other.
2. The most intiutive way to solve this problem is to think that if we divide the total sum of the entire list by 2 (two equal partitions). Then we have the sum of one partition. If we find the sum of one partition, with any combinations of numbers we can return true. This logic also points to an edge case, if the sum of the given list of numbers is odd. Then we wont be able to find equal sum of the partitions. In that case we will return False.
3. So the brute force way of solving this problem is that for each element in the list we have two choices, whether to include it in the sum or not include in the sum. The target sum we are looking for is `target = sum(nums) // 2` . We draw a decision tree, going through all the possible subset sums, if at any point we find the target we will simple retrun True. Otherwise if have traversed the entire decison tree and didnot find the target we will return False. This approach takes O(2 ^ n) time complexity.
4. Doing this problem according to the Top Down DP approach, at each choice we have a new subproblem. This new subproblem strats with the next index i, and a new target value. So we can implementing caching at each decision we have two dimensionsal caching, one is the index and other is the remaining target. This top down approach will take O(n. sum(nums)) time and same amount of space complexity, but this solution is better than the O(2 ^ n). But if we try to do this problem in bottom up approach we will have the same time complexity but a little bit better space complexity. O(sum(nums)) is not very big given the constraints of the problem. If the sums(nums) is really big like in millions then this is a very expensive algorithm.
5. For the bottom up approach, we should think about that if we know all the possible sums in the remaining subarray. Then we can simply cycle through all the possible sums up until this index and check if they are equal to the target. If any of the sum is equal to the target then we simply return true. We will also return True if any of the sums up until this index plus the number at the current index equals to the target. If not then we can simply add this new sum to are cache.
6. So we are looking to stash all the possible sums, we dont need duplicate sums since we are only looking for one target sum. Since we are not looking for duplicate sums we will use a Hashset as our caching Data structure.
7. Then its a good idea to traverse the list from the end. We already have a sum (zero) in the Hashset. Then we cycle through the entire set and and check if any of the sums + current value equal the target. If it does then we simply return True. Otherwise we add this new sum to the hashset. Outside this nested loop we check if any of the sums in the Hashset equals to the target and return the result of the comparision.
8. PRoTip: When we cycle through the Hashset, we cannot add values to the Hashset at the same time, that way we will get into an infinite loop. So the idea is to make a copy of the current Hashset before cycling through the Hashset. Then we add all the old sums as well as the new sum in this copy Hashset. And once we have completed the cycle then we can reassign the old Hashset by setting it to the copy Hashset.
9. The time complexity of this solution is O(n. sum(nums)) and the space complexity is O(sums(nums))
