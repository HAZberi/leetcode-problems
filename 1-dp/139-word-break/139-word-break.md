**Notes:** 

1. The problem asks us to find out whether a given string can be broken into segments such that each segment matches a word in the given dictionary of words. We can use a word from the given dictionary multiple times.
2. There are two ways to solve this problem and one way is more efficient then the second one. The first approach is to start from each character and check whether its a word in the dictionary or not. Then take two characters, check if they are in the list, then take 3 and check. Keep doing that for the entire "n" length of the string. Then start from the second character repeat the same process. This nested approach will be O(n ^ 2) and since we will also be comparing strings where each comparison will also take O(n) in worst case. So the overall time complexity of this first approach will be O(n ^ 3)
3. The second approach is a bit more efficient. Starting from string index 0 we take the entire length of each word in the word dict and then compare this segment of characters with the word. We can clearly notice that this approach is more efficient. Now instead of O(n ^ 2) we are having O(n . m) time. And by looking at the constraints of the problem we can also see that m < n. Meaning the length of wordDict is less than the length of the given string. Since we also have to compare the strings, so the overall time complexiy is O(n. m. n) => O(m. n ^ 2)
4. It is better to have a decision tree built for this problem, starting from index 0 we will have (length of wordDict) choices. If any word does not match the string segment, we will not continue that path. If a word matches only that branch or path can be continued. If a segment matches then the index i = i + len(w). We keep on adding branches until we reach a point where index i = i + len(w) = len(string). If i reaches the length of the string, it means we can return True. All the other cases we will return false. If we keep a cache, we can store the result of each index, and if we come back to that index in some other branch we can take the result from the cache.
5. For the bottom up approach we will start from the end. We know if we reach the end of the given string or when i == len(s), it means we have successfully broken the string. So we initialize it in our cache(dp) to True. Then for each index we compare the segment of the string that is equal to the length of each word in the string and also make sure that we don't go out of bounds. We keep on doing that and then we found the first word that matches. So if the word matches then what should be the dp equation we should rely on? We know if i == len(s) we have true. So for the current index, we already know that it matches a word of length L. So the segment after the [currentIndex + length of the word] in the given string is true or not? So the Dp equation comes out to be `dp[i] = dp[currentIndex - lengthoftheWord]. `
6. One more thing which is related to caching, At any point in our nested loop, current index result in the cache is true. We should immediately break out of the inner loop and continue to the next index.
7. ProTip: The outer for loop must start in reverse, because we are going bottom up. This way we only have to return dp[0]. Also our dp(cache) is an array of length string + 1. To acomodate our good edge case.
