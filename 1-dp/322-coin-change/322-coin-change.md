**Notes:**

1. The problem ask us to find the minimum number of coins needed to make up to the given amount. We are given a list coin and and an amount.
2. The first method that come right of the bat, so use a greedy approach. What if we take the first coin as closest as possible to the actual amount. Then we check whether the adding the smaller coins make up to the target. We might be able to reach the amount but the number of coin would not be the minimum to reach the amount. So a greedy solution will not work.
3. So the best way to approach a complex dynamic program is to draw a decision tree. A decision tree will help us in identifying the underlying pattern of the problem that helps us in identifying the recursive case equation. So in this problem, we can start with any coin, so basically we will have all the coins having there own branches. At each branch we will calculate how much change has left. `amountLeft = amount - coinValue` . Then from each branch we can pick any coin, then again we will calculate the amountLeft. When the amountLeft becomes 0. It means we have a solution, the number of coins is equal to the depth of this path. The solution may or may not be the minimum number of coins, so we keep a global variable and keep updating it until we have looked through all the paths.
4. Let's now take this problem with the bottom up approach. We can go from 0 - amount. So if the amount is 0, how many coins do we need? 0 coins. This is simple, so we start from here. Now the amount is 1, how many coins do we need? We must need at least 1 coin to return the change. So for any amount we need at least one coin to return. Well now the question is how many more coins are needed? We need the number of coins required for this amount minus the current value of the coin. Here we cycle through all the coins and see whether this current coin is enough to make up the amount. Here if we get a current coin value as 1. Only then we will be able to return the change for amount. If the current coin value is greater than the amount then in that case we will have to return -1. Meaning we cannot provide the change. So the overall dynamic equation comes down to `coinsNeededForAmount = 1 + coinsNeededFor[Amount - CurrentCoinValue] dp[i] = 1 + dp[a - c].`
5. So basically we will get an array of size (amount + 1), this will be our cache. Each value can be initialized to amount + 1, because its the maximum amount possible, and it will help us in catching unsolvable amounts, so we can return -1. After that we set the 0 amount with 0 value, because 0 amount means 0 coins are needed. The we loop over the amount range from 1 - amount. And for each amount value, we loop thourgh all the coins in the coin list. We will check whether the differnce of amount and coin is greater than 0. It means, it is possible to return the change. Then we take the current amount in our cache and set it to minimum of its current value and 1 + dp[a-c]. Outside the nested loop we chech if the amount in our cache is not equal to amount + 1. Then we simply return the value otherwise we will return false.
6. The time complexity of this solution will O(amount * len(coinList)) which is apparent from the code as well. And the space complexity is O(amount + 1)
