**Notes:**

1. The problem asks us find the total number of ways a string of digits can be decoded. A dictionary is given where numbers 1-26 are mapped to A-Z. So if a string is "11". It can be decoded in 2 ways => "AA" and => "L". If a string is "10". It can be decoded in only one way => "K". Beacuse 0 cannot be decoded.
2. The brute force approach to this problem is draw a decison tree, where at each level we have a choice, decode only one digit or decode two digits. If we encounter a zero as singal digit, that will mean we cannot go further down this path, so we return zero. If we encounter any two digits greater than 26, we also cannot go any further down this path, so we can return zero. If going down any path we reach the end of the list, we will return one because we have successfully found a path. We can add 1 to our result. If we code this approach recursively then the time complexity will be O(2^n).
3. If we implement caching then we bring down the time complexity to O(n). That would be top-down dynamic programming approach. So if we want to identify the sub-problems, we have two subproblem, ways to decode 1 digit or ways to decode 2 digits together. If we know the ways to decode the next 1 digit and also know the ways to decode the next 2 digits. We can simply add these two to get the number of ways the current digit can be decoded. `dp[i] = dp[i + 1] + dp[i + 2]`
4. Since we are discussing the top-down dynamic programming approach. We will first start with edge cases. How do we know reach the end of the string and have successfully found a way? If we successfully find a way it means we have to return 1. Recursively thinking, how many ways the last digit can be decoded. At this point we will check ways of the next digit but we will go out of bounds. So basically whenever we reach the length of string it means we have found a path and we should return 1. We add this default to our global cache "dp".
5. Now in the recursive function we will first check whether the ways from current index already present in our cache. If yes then we return the value from cache. Then we check whether the current digit is decodable, if its a zero, we will simply return 0.
6. After checking all the good and bad edge cases. We have a decodable digit, if we choose this single digit then we need to know the number of ways next digit can be reached. So here, we will make the recursive call with i + 1 and store the result. But this may be not the total number of ways to decode from here. We also need to choose 2 digits together and those two digits must be less than 27. If the two digits are decodable then we recursively call with i + 2 and add that to the result for current index.
7. Now the result for this index has successfully calculated, and then simply return the result. The total number of ways a string can be decode from this index onwards. Before returning the result we also need to add this result at index i to our cache.
8. ProTip: When checking for two digits, we need to make sure the second digit is in bounds, the first character can be either 1 or 2. And if its 2 then the second digit must be in "0123456".
9. I have also implemented the bottom up approach to this problem, which is exactly the same conceptually.
